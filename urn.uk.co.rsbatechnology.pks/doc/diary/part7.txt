=Part 7: Position Delta Resource Model=

I now had a basic working Currency Position resource model, with a service accessor endpoint, and an aliased shortcut endpoint.  Next, I needed an equivalent resource model for Position Deltas ... the position change records, generated by Position Builders, that must be applied to current positions to update them.

==Position Delta Resource Representation==

A Position Delta record is a unique, time-ordered object, that records:

* The identity of the position record being altered
* The delta action (CREDIT, DEBIT or SYNC)
* The amount changes (increment, decrement, or full amount, for the 3 delta actions respectively)
* Some indication of the time-ordering of each delta.  
* Some information about the position-originating transaction (type, id) to support traceability from a position, through its position deltas, and then back to the original transactions.

A possible HDS representation of a position delta might look like this:

{literal}
<positionDelta>
	<@positionID>EFX:LDN:PRE_STP:ef79b770-b605-11e3-a5e2-0800200c9a66:OPEN:2014.03.27:EUR</@id>
	<deltaSequence>1399554731345</deltaSequence>
	<deltaAmounts>
		<deltaAmount>
			<action>DEBIT</action>
			<type>SETTLEMENT</type>
		 	<symbol>EUR</symbol>
		 	<value>10000</value>
		</deltaAmount>
		<deltaAmount>
			<action>DEBIT</action>
			<type>BASE</type>
		 	<symbol>USD</symbol>
		 	<value>13000</value>
		</deltaAmount>
	</deltaAmounts>
	<sourceTransaction>
		<id>9f8a49c9-3111-417a-9024-80e7c9c69595</id>
		<version>1</version>
	</sourceTransaction>
</positionDelta>
{/literal}

Notes:
# At this stage, I don't know how to represent the identity of a source transaction as a ROC identifier.  But any such identifier would need to be a combination of a globally-unique identifier (in this case, a UUID), and a transaction lifecycle version number.
# How to represent a persisted atomic increasing sequence number in NetKernel, that has to be unique per position identifier?  For now, I'll cheat and use a millisecond - accuracy timestamp.  

A service endpoint to persist a position delta, '''active:positionDelta''', would take arguments for the position identity attributes, sequence number, and source transaction. The primary argument would be the list of <code><deltaAmounts></code>.

To uniquely identify a position delta, I used the position shortcut format, plus the deltaSequence number at the end:

{literal}
delta:EFX:LDN:PRE_STP:ef79b770-b605-11e3-a5e2-0800200c9a66:NET:2014.03.27:EUR:1399554731345

pds:/pks/delta/EFX:LDN:PRE_STP:ef79b770-b605-11e3-a5e2-0800200c9a66:NET:2014.03.27:EUR:1399554731345
{/literal}

==Position Delta active:positionDelta endpoint==

Based on the pattern I had established for the position resource model, I created two '''active:positionDelta''' endpoints (one for SINK, one for SOURCE/EXISTS/DELETE).  

{xml}
<config>
	<endpoint>
		<description>Service to retrieve a single position delta resource
		</description>
		<verbs>SOURCE,DELETE,EXISTS</verbs>
		<grammar>
			<active>
				<identifier>active:positionDelta</identifier>
				<argument name="businessArea" desc="Business area partition to which position belongs" />
				<argument name="location" desc="Owning business location of position" />
				<argument name="lifecycleType" desc="Position transaction lifecycle type" />
				<argument name="accountUUID" desc="Position Account UUID" />
				<argument name="positionType" desc="Position calculation type" />
				<argument name="positionDate" desc="Record date of position" />
				<argument name="positionSymbol" desc="Instrument symbol of position" />
				<argument name="deltaSequence" desc="Position delta sequence number (Millis since 1/1/1970T00:00:00Z)" />
			</active>
		</grammar>
		<request>
			<identifier>pds:/pks/delta/[[arg:businessArea]]:[[arg:location]]:[[arg:lifecycleType]]:[[arg:accountUUID]]:[[arg:positionType]]:[[arg:positionDate]]:[[arg:positionSymbol]]:[[arg:deltaSequence]]
			</identifier>
		</request>
	</endpoint>
	<endpoint>
		<description>Service to persist a single position delta resource
		</description>
		<verbs>SINK</verbs>
		<grammar>
			<active>
				<identifier>active:positionDelta</identifier>
				<argument name="businessArea" desc="Business area partition to which position belongs" />
				<argument name="location" desc="Owning business location of position" />
				<argument name="lifecycleType" desc="Position transaction lifecycle type" />
				<argument name="accountUUID" desc="Position Account UUID" />
				<argument name="positionType" desc="Position calculation type" />
				<argument name="positionDate" desc="Record date of position" />
				<argument name="positionSymbol" desc="Instrument symbol of position" />
				<argument name="deltaSequence" desc="Position delta sequence number (Millis since 1/1/1970T00:00:00Z)" />
				<argument name="sourceTransaction" desc="Position delta source transaction" />
			</active>
		</grammar>
		<request>
			<identifier>active:groovy</identifier>
			<argument name="operator">res:/uk/co/rsbatechnology/pks/sinkPositionDelta.groovy</argument>
			<argument name="businessArea">arg:businessArea</argument>
			<argument name="location">arg:location</argument>
			<argument name="lifecycleType">arg:lifecycleType</argument>
			<argument name="accountUUID">arg:accountUUID</argument>
			<argument name="positionType">arg:positionType</argument>
			<argument name="positionDate">arg:positionDate</argument>
			<argument name="positionSymbol">arg:positionSymbol</argument>
			<argument name="deltaSequence">arg:deltaSequence</argument>
			<argument name="sourceTransaction">arg:sourceTransaction</argument>
		</request>
	</endpoint>
	<endpoint>
		<description>Shortcut alias to retrieve a single position delta resource
		</description>
		<verbs>SOURCE,DELETE,EXISTS</verbs>
		<grammar>
			<simple>delta:{businessArea}:{location}:{lifecycleType}:{accountUUID}:{positionType}:{positionDate}:{positionSymbol}:{deltaSequence}
			</simple>
		</grammar>
		<request>
			<identifier>active:positionDelta</identifier>
			<argument name="businessArea">arg:businessArea</argument>
			<argument name="location">arg:location</argument>
			<argument name="lifecycleType">arg:lifecycleType</argument>
			<argument name="accountUUID">arg:accountUUID</argument>
			<argument name="positionType">arg:positionType</argument>
			<argument name="positionDate">arg:positionDate</argument>
			<argument name="positionSymbol">arg:positionSymbol</argument>
			<argument name="deltaSequence">arg:deltaSequence</argument>
		</request>
	</endpoint>
</config>
{/xml}

The '''sinkPositionDelta.groovy''' script was simple to write, based on the '''sinkPosition.groovy''' file, with only the following lines added:

{java}
...
deltaSequence = context.getThisRequest().getArgumentValue("deltaSequence")
...
IHDSNode sourceTransaction = context.source("arg:sourceTransaction", IHDSNode.class)
IHDSNode firstSourceTransactionNode = sourceTransaction.getFirstNode("/sourceTransaction")

...

// Create HDS structure
b = new HDSBuilder()
b.pushNode("positionDelta")
b.addNode("@id", positionDeltaIdentifier)
b.addNode("deltaSequence", deltaSequence)
b.importNode(firstAmountsNode)
b.importNode(firstSourceTransactionNode)

// Use PDS to SINK position delta node
context.sink("pds:/pks/delta/"+positionDeltaIdentifier, b.getRoot())
{/java}


==Refactoring==
I took the opportunity to do some re-factoring of the PKS module mapper config and the XUnit tests.  

* Added the position cache endpoints in a new '''positionDeltaCacheMapperConfig.xml''' file, and added as a second <code><import></code> in the mapper <code><config>...</config></code> list.
* Split the XUnit unit tests into two separate xml files, and imported both of them into the main '''testlist.xml''' file.

<blockquote>
I tried to use the XUnit <code><group></code> element to import the two test xml files, but this seemed to be ignored by the NK XUnit system.  So, I resorted to using <code><import></code>statements instead.  This worked, but appears to have a significant disadvantage in that the XUnit results page does not list the results of each test individually.
</blockquote>

==The active:allPositionDeltas endpoint==

I created a '''active:allPositionDeltas''' endpoint, based very closely on the '''active:allPositions''' endpoint.  But, when I came to test it, it kept failing because the retrieved list of delta records was empty. Using the Visualizer, I noticed that the requests to '''active:positionDelta''' from the '''setup2positionDeltas.dpml''' script looked like this:

{literal}
active:positionDelta+accountUUID@res%3A/test/ef79b770-b605-11e3-a5e2-0800200c9a66+businessArea@pbv%3Aeb3b8583+deltaSequence@res%3A/test/1399554731345+lifecycleType@pbv%3Aeb3b8585+location@pbv%3Aeb3b8584+positionDate@res%3A/test/2014.03.27+positionSymbol@res%3A/test/EUR+positionType@pbv%3Aeb3b8586+sourceTransaction@pbv%3Aeb3b8587
{/literal}

Compare this with the other positionDelta XUnit test that SINKed a position delta record directly in the <code><setup></code> element of the test, instead of using a separate DPML file:

{literal}
active:positionDelta+accountUUID@ef79b770-b605-11e3-a5e2-0800200c9a66+businessArea@EFX+deltaSequence@1399554731345+lifecycleType@PRE_STP+location@LDN+positionDate@2014.03.27+positionSymbol@EUR+positionType@NET+sourceTransaction@pbv%3AsourceTransaction
{/literal}

I realised that DPML was assuming the argument values were resource identifiers, not literal constants.  I then changed the arguments from this:

{xml}
		<argument name="businessArea">EFX</argument>
{/xml} 

to this:

{xml}
		<argument name="businessArea">
			<literal type="string">EFX</literal>
		</argument>
{/xml} 

Suddenly, the ''allPositionDeltas'' test was passing.

'''BUT''', when I inspected the test output , I saw this:

{xml}
<positionDeltas>
	<positionDelta xmlns:hds="http://netkernel.org/hds" id="pbv:eb3b8583:pbv:eb3b8584:pbv:eb3b8585:pbv:eb3b8587:pbv:eb3b8586:pbv:eb3b8588:pbv:eb3b8589:pbv:eb3b858a">
	<deltaSequence>pbv:eb3b858a</deltaSequence>
	...
	</positionDelta>
</positionDeltas>
{/xml}

With help from Peter Rodgers at 1060Research, I realised that the '''sinkPositionDelta.groovy''' code was now wrong.  Instead of assigning the request argument variables using <code>getArgumentValue(...)</code>, it had to use <code>context.source("arg:businessArea")</code>. This ensured that the variable was being assigned from the representation of the argument (ie. from the '''pbv''' pass-by-value space), not the argument value itself (a '''pbv''' space identifier).  This also meant I had to change all argument values in the position delta tests to use explicit <code><literal></code> argument values.

After some more faffing about,I got the XUnit test for '''active:allPositionDeltas''' working OK. But then the first test, for an individual position delta SINK / SOURCE / DELETE test reported an exception.  The SINK request worked OK in the setup step, but the test request was failing to find the corresponding record using the '''pds/pks/delta/...''' PDS identifier:

{xml}
   <message>Resource [pds:/pks/delta/pbv:businessArea:pbv:location:pbv:lifecycleType:pbv:accountUUID:pbv:positionType:pbv:positionDate:pbv:positionSymbol:pbv:deltaSequence] in zone [global:pks] does not exist</message>
{/xml}

The problem now was that the test request of the '''active:positionDelta''' for SOURCEing had been converted to use <code><literal></code> arguments, but the endpoint declaration was using them as simple identifiers:

{xml}
	<endpoint>
		<description>Service to retrieve a single position delta resource
		</description>
		<verbs>SOURCE,DELETE,EXISTS</verbs>
		<grammar>
			<active>
				<identifier>active:positionDelta</identifier>
				<argument name="businessArea" desc="Business area partition to which position belongs" />
				<argument name="location" desc="Owning business location of position" />
				<argument name="lifecycleType" desc="Position transaction lifecycle type" />
				<argument name="accountUUID" desc="Position Account UUID" />
				<argument name="positionType" desc="Position calculation type" />
				<argument name="positionDate" desc="Record date of position" />
				<argument name="positionSymbol" desc="Instrument symbol of position" />
				<argument name="deltaSequence" desc="Position delta sequence number (Millis since 1/1/1970T00:00:00Z)" />
			</active>
		</grammar>
		<request>
			<identifier>pds:/pks/delta/[[arg:businessArea]]:[[arg:location]]:[[arg:lifecycleType]]:[[arg:accountUUID]]:[[arg:positionType]]:[[arg:positionDate]]:[[arg:positionSymbol]]:[[arg:deltaSequence]]
			</identifier>
		</request>
	</endpoint>
{/xml} 

In order to handle the arguments as pass-by-value, the endpoint could not use the grammar - parsing syntax alone ... <code>[[arg:businessArea]]</code> resolved to <code>pbv:businessArea</code> and not <code>EFX</code> as before.

Therefore, I could either change the way arguments were expected between the SINK (literals) and SOURCE (identifiers), which would be horribly inconsistent, or change the implementation of the SOURCE endpoint to use a groovy script to resolve the argument values before building the PDS identifier (exactly the same way as the SINK script does). I chose to do the latter.

I could have copy & pasted the '''sinkPositionDelta.groovy''' script into a '''sourcePositionDelta.groovy''' script, but there would be duplicate argument - handling code.

Instead, I added a request verb - handling <code>switch</code> statement, and changed the implementing request for the SOURCE '''active:positionCache''' endpoint to resolve to '''sinkPositionCache.groovy'''

{java}
switch (context.getThisRequest().getVerb())
{
	case INKFRequestReadOnly.VERB_SINK:
		IHDSNode sourceTransaction = context.source("arg:sourceTransaction", IHDSNode.class)
		IHDSNode firstSourceTransactionNode = sourceTransaction.getFirstNode("/sourceTransaction")
		// TODO: Check if null, throw exception
		
		IHDSNode deltaAmounts = context.sourcePrimary(IHDSNode.class)
		IHDSNode firstAmountsNode = deltaAmounts.getFirstNode("/deltaAmounts")
		// TODO: Check if null, throw exception
		
		// Create HDS structure
		b = new HDSBuilder()
		b.pushNode("positionDelta")
		b.addNode("@id", positionDeltaIdentifier)
		b.addNode("deltaSequence", deltaSequence)
		b.importNode(firstAmountsNode)
		b.importNode(firstSourceTransactionNode)
		
		// Use PDS to SINK position delta node
		context.sink(POSITION_DELTA_PDS_PREFIX+positionDeltaIdentifier, b.getRoot())
		break
	case INKFRequestReadOnly.VERB_SOURCE:
		request = context.createRequest(POSITION_DELTA_PDS_PREFIX+positionDeltaIdentifier)
		response = context.issueRequestForResponse(request)
		context.createResponseFrom(response)
		break
	case INKFRequestReadOnly.VERB_DELETE:
		request = context.createRequest(POSITION_DELTA_PDS_PREFIX+positionDeltaIdentifier)
		request.setVerb(INKFRequestReadOnly.VERB_DELETE)
		response = context.issueRequestForResponse(request)
		context.createResponseFrom(response)
		break
	case INKFRequestReadOnly.VERB_EXISTS:
		request = context.createRequest(POSITION_DELTA_PDS_PREFIX+positionDeltaIdentifier)
		request.setVerb(INKFRequestReadOnly.VERB_EXISTS)
		response = context.issueRequestForResponse(request)
		context.createResponseFrom(response)
		break
}
{/java}

==The shortcut delta: alias endpoint==

The last change I needed to do was to convert the literal arguments of the '''delta:''' shortcut aliasd endpoint to ''pass-by-value'' arguments into the call of '''active:positionCache''', using the declarive request argument '''method''' attribute:

{xml}
		<request>
			<identifier>active:positionDelta</identifier>
			<argument name="businessArea" method="as-string">arg:businessArea</argument>
			<argument name="location"  method="as-string">arg:location</argument>
			<argument name="lifecycleType" method="as-string">arg:lifecycleType</argument>
			<argument name="accountUUID" method="as-string">arg:accountUUID</argument>
			<argument name="positionType" method="as-string">arg:positionType</argument>
			<argument name="positionDate" method="as-string">arg:positionDate</argument>
			<argument name="positionSymbol" method="as-string">arg:positionSymbol</argument>
			<argument name="deltaSequence" method="as-string">arg:deltaSequence</argument>
		</request>
{/xml}
 

